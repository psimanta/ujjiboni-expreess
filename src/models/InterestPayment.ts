import mongoose, { Document, Schema } from 'mongoose';

export enum InterestPaymentStatus {
  PENDING = 'PENDING',
  PAID = 'PAID',
  OVERDUE = 'OVERDUE',
  PARTIAL = 'PARTIAL',
}

export enum PaymentMethod {
  CASH = 'CASH',
  BANK_TRANSFER = 'BANK_TRANSFER',
  CHEQUE = 'CHEQUE',
  ONLINE = 'ONLINE',
  UPI = 'UPI',
}

export interface IInterestPayment extends Document {
  loanId: mongoose.Types.ObjectId;
  paymentNumber: string;
  dueDate: Date;
  paymentDate?: Date;
  dueAmount: number;
  paidAmount: number;
  outstandingBalance: number; // Outstanding principal at the time of this interest calculation
  interestRate: number; // Interest rate used for this calculation
  monthlyInterestRate: number; // Monthly rate used
  status: InterestPaymentStatus;
  paymentMethod?: PaymentMethod;
  paidBy?: mongoose.Types.ObjectId;
  receivedBy?: mongoose.Types.ObjectId;
  receiptNumber?: string;
  transactionReference?: string;
  penaltyAmount?: number;
  lateFeeAmount?: number;
  notes?: string;
  isAutoGenerated: boolean; // Whether this was auto-generated or manually created
  createdAt: Date;
  updatedAt: Date;
}

export interface IInterestPaymentModel extends mongoose.Model<IInterestPayment> {
  generatePaymentNumber(): Promise<string>;
  findByLoan(loanId: string): mongoose.Query<IInterestPayment[], IInterestPayment>;
  findOverduePayments(): mongoose.Query<IInterestPayment[], IInterestPayment>;
  findPendingPayments(): mongoose.Query<IInterestPayment[], IInterestPayment>;
  getPaymentSummary(loanId?: string, memberId?: string): Promise<any>;
  generateMonthlyInterest(loanId: string): Promise<IInterestPayment>;
}

const interestPaymentSchema = new Schema<IInterestPayment>(
  {
    loanId: {
      type: Schema.Types.ObjectId,
      ref: 'Loan',
      required: true,
      index: true,
    },
    paymentNumber: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    dueDate: {
      type: Date,
      required: true,
      index: true,
    },
    paymentDate: {
      type: Date,
      index: true,
    },
    dueAmount: {
      type: Number,
      required: true,
      min: [0, 'Due amount must be non-negative'],
    },
    paidAmount: {
      type: Number,
      required: true,
      min: [0, 'Paid amount must be non-negative'],
      default: 0,
    },
    outstandingBalance: {
      type: Number,
      required: true,
      min: [0, 'Outstanding balance must be non-negative'],
    },
    interestRate: {
      type: Number,
      required: true,
      min: [0, 'Interest rate must be non-negative'],
    },
    monthlyInterestRate: {
      type: Number,
      required: true,
      min: [0, 'Monthly interest rate must be non-negative'],
    },
    status: {
      type: String,
      enum: Object.values(InterestPaymentStatus),
      default: InterestPaymentStatus.PENDING,
      required: true,
    },
    paymentMethod: {
      type: String,
      enum: Object.values(PaymentMethod),
    },
    paidBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    receivedBy: {
      type: Schema.Types.ObjectId,
      ref: 'User',
    },
    receiptNumber: {
      type: String,
      trim: true,
    },
    transactionReference: {
      type: String,
      trim: true,
    },
    penaltyAmount: {
      type: Number,
      min: [0, 'Penalty amount must be non-negative'],
      default: 0,
    },
    lateFeeAmount: {
      type: Number,
      min: [0, 'Late fee amount must be non-negative'],
      default: 0,
    },
    notes: {
      type: String,
      trim: true,
      maxlength: [500, 'Notes cannot exceed 500 characters'],
    },
    isAutoGenerated: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: function (_, ret) {
        // ret.id = ret._id;
        delete ret._id;
        delete ret.__v;
        return ret;
      },
    },
  }
);

// Indexes for better performance
interestPaymentSchema.index({ loanId: 1, dueDate: 1 });
interestPaymentSchema.index({ status: 1, dueDate: 1 });
interestPaymentSchema.index({ dueDate: 1 });

// Pre-save middleware to update status based on payment
interestPaymentSchema.pre('save', function (next) {
  if (this.isModified('paidAmount') || this.isModified('dueAmount')) {
    if (this.paidAmount === 0) {
      this.status =
        new Date() > this.dueDate ? InterestPaymentStatus.OVERDUE : InterestPaymentStatus.PENDING;
    } else if (this.paidAmount >= this.dueAmount) {
      this.status = InterestPaymentStatus.PAID;
      if (!this.paymentDate) {
        this.paymentDate = new Date();
      }
    } else {
      this.status = InterestPaymentStatus.PARTIAL;
    }
  }
  next();
});

// Static method to generate payment number
interestPaymentSchema.statics.generatePaymentNumber = async function (): Promise<string> {
  const currentYear = new Date().getFullYear();
  const currentMonth = (new Date().getMonth() + 1).toString().padStart(2, '0');
  const prefix = `INT${currentYear}${currentMonth}`;

  const lastPayment = await this.findOne({
    paymentNumber: { $regex: `^${prefix}` },
  }).sort({ paymentNumber: -1 });

  let sequence = 1;
  if (lastPayment) {
    const lastSequence = parseInt(lastPayment.paymentNumber.substring(prefix.length));
    sequence = lastSequence + 1;
  }

  return `${prefix}${sequence.toString().padStart(4, '0')}`;
};

// Static method to find payments by loan
interestPaymentSchema.statics.findByLoan = function (loanId: string) {
  return this.find({ loanId })
    .populate('loanId', 'loanNumber principalAmount interestRate')
    .populate('paidBy', 'fullName email')
    .populate('receivedBy', 'fullName email')
    .sort({ dueDate: -1 });
};

// Static method to find overdue payments
interestPaymentSchema.statics.findOverduePayments = function () {
  return this.find({
    status: { $in: [InterestPaymentStatus.OVERDUE, InterestPaymentStatus.PARTIAL] },
    dueDate: { $lt: new Date() },
  })
    .populate('loanId', 'loanNumber principalAmount')
    .populate('paidBy', 'fullName email')
    .sort({ dueDate: 1 });
};

// Static method to find pending payments
interestPaymentSchema.statics.findPendingPayments = function () {
  return this.find({
    status: { $in: [InterestPaymentStatus.PENDING, InterestPaymentStatus.PARTIAL] },
  })
    .populate('loanId', 'loanNumber principalAmount')
    .populate('paidBy', 'fullName email')
    .sort({ dueDate: 1 });
};

// Static method to get payment summary
interestPaymentSchema.statics.getPaymentSummary = async function (
  loanId?: string,
  memberId?: string
) {
  const matchStage: any = {};

  if (loanId) {
    matchStage.loanId = new mongoose.Types.ObjectId(loanId);
  }

  if (memberId) {
    matchStage.paidBy = new mongoose.Types.ObjectId(memberId);
  }

  const summary = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 },
        totalDue: { $sum: '$dueAmount' },
        totalPaid: { $sum: '$paidAmount' },
        totalPenalty: { $sum: '$penaltyAmount' },
        totalLateFee: { $sum: '$lateFeeAmount' },
      },
    },
  ]);

  const result = {
    totalPayments: 0,
    pendingPayments: 0,
    paidPayments: 0,
    overduePayments: 0,
    partialPayments: 0,
    totalDueAmount: 0,
    totalPaidAmount: 0,
    totalPenaltyAmount: 0,
    totalLateFeeAmount: 0,
    totalOutstanding: 0,
  };

  summary.forEach(item => {
    result.totalPayments += item.count;
    result.totalDueAmount += item.totalDue;
    result.totalPaidAmount += item.totalPaid;
    result.totalPenaltyAmount += item.totalPenalty;
    result.totalLateFeeAmount += item.totalLateFee;

    switch (item._id) {
      case InterestPaymentStatus.PENDING:
        result.pendingPayments = item.count;
        break;
      case InterestPaymentStatus.PAID:
        result.paidPayments = item.count;
        break;
      case InterestPaymentStatus.OVERDUE:
        result.overduePayments = item.count;
        break;
      case InterestPaymentStatus.PARTIAL:
        result.partialPayments = item.count;
        break;
    }
  });

  result.totalOutstanding = result.totalDueAmount - result.totalPaidAmount;

  return result;
};

// Static method to generate monthly interest payment
interestPaymentSchema.statics.generateMonthlyInterest = async function (
  loanId: string
): Promise<IInterestPayment> {
  const Loan = mongoose.model('Loan');
  const loan = await Loan.findById(loanId);

  if (!loan) {
    throw new Error('Loan not found');
  }

  if (loan.status !== 'ACTIVE') {
    throw new Error('Interest can only be generated for active loans');
  }

  // Calculate outstanding balance
  const outstandingBalance = await loan.calculateOutstandingBalance();

  if (outstandingBalance <= 0) {
    throw new Error('No outstanding balance for interest calculation');
  }

  // Calculate due amount
  const dueAmount = outstandingBalance * loan.monthlyInterestRate;

  // Calculate due date (next month from last payment or disbursement date)
  const lastInterestPayment = await this.findOne({ loanId }).sort({ dueDate: -1 });

  let dueDate: Date;
  if (lastInterestPayment) {
    dueDate = new Date(lastInterestPayment.dueDate);
    dueDate.setMonth(dueDate.getMonth() + 1);
  } else {
    dueDate = new Date(loan.disbursedDate);
    dueDate.setMonth(dueDate.getMonth() + 1);
  }

  // Generate payment number
  const paymentNumber = await (this.constructor as IInterestPaymentModel).generatePaymentNumber();

  // Create interest payment record
  const interestPayment = new this({
    loanId,
    paymentNumber,
    dueDate,
    dueAmount,
    paidAmount: 0,
    outstandingBalance,
    interestRate: loan.interestRate,
    monthlyInterestRate: loan.monthlyInterestRate,
    status: InterestPaymentStatus.PENDING,
    isAutoGenerated: true,
  });

  await interestPayment.save();
  return interestPayment;
};

const InterestPayment = mongoose.model<IInterestPayment, IInterestPaymentModel>(
  'InterestPayment',
  interestPaymentSchema
);

export { InterestPayment };
export default InterestPayment;
